function [mod] = riderfunc(X,s,i,mod)

    % Declarations/limitations
    Gnm = 900/(s^2 + 2*.707*30*s + 900);
    delay = exp(-0.06*s);

    mod.X = X;
    mod.C =  mod.X*[eye(2); eye(2)/s; eye(2)*s];
    % Casewise multiple model structures
    switch i
        case 1; % PID controller
%             mod.X =  X;
            mod.K = -mod.C*Gnm;
        case 2; % reduced PID type controller
%             mod.X = [0 X];
            mod.K = -mod.C*Gnm;
        case 3; % reduced PID controller
%             mod.X = [0 X(1) X(2) 0 X(3) X(4)];
            mod.K = -mod.C*Gnm;
       case 4; % 5 parameter PID type controller with delay
%             mod.X = [0 X];
            mod.K = -mod.C*Gnm*delay;
       case 5; % 4 parameter PID type controller with delay
%             mod.X = [0 X(1) X(2) X(3) X(4) 0 ];
            mod.K = -mod.C*Gnm*delay;
        otherwise
        disp('Non existing model number input');
    end

    % Calculate closed loop system responses
    me = [];
    mod.z = mod.G.zw + mod.G.zu*((eye(1)-mod.K*mod.G.yu)\mod.K*mod.G.yw);
    mod.y = mod.G.yw + mod.G.yu*((eye(1)-mod.K*mod.G.yu)\mod.K*mod.G.yw);
    try mod.y =  minreal(mod.y); catch me; end
    try mod.z =  minreal(mod.z); catch me; end
    disp(me);
    
     